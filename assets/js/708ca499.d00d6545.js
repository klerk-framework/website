"use strict";(self.webpackChunkklerk_website=self.webpackChunkklerk_website||[]).push([[8],{3573:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=t(4848),s=t(8453);const a={sidebar_position:5},o="State machines",r={id:"building-config/state-machines",title:"State machines",description:"Let's look at an example where we declare the flow of an invoice:",source:"@site/docs/building-config/state-machines.md",sourceDirName:"building-config",slug:"/building-config/state-machines",permalink:"/klerk/docs/building-config/state-machines",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Models and Types",permalink:"/klerk/docs/building-config/models-types"},next:{title:"Authorization",permalink:"/klerk/docs/building-config/authorization"}},l={},c=[{value:"Events",id:"events",level:2},{value:"States",id:"states",level:2},{value:"Blocks and executables",id:"blocks-and-executables",level:2},{value:"Transactions",id:"transactions",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"state-machines",children:"State machines"}),"\n",(0,i.jsx)(n.p,{children:"Let's look at an example where we declare the flow of an invoice:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"stateMachine {\n    externalEvents {\n        event(CreateInvoice, CreateInvoiceParams::class)\n        event(Delete)\n        event(Aprove)\n        event(Pay)\n    }\n\n    voidState {\n        onEvent(CreateInvoice) {\n            createModel(WaitingForApproval, ::newInvoice)\n        }\n    }\n\n    state(WaitingForApproval) {\n        onEnter {\n            action(::sendEmailToApprover)\n        }\n\n        onEvent(Delete) {\n            delete()\n        }\n\n        onEvent(Approve) {\n            transitionTo(Approved)\n        }\n    }\n\n    state(Approved) {\n        onEvent(Pay) {\n            transitionTo(Payed)\n        }\n\n        onEvent(Delete) {\n            delete()\n        }\n    }\n\n    state(Payed) {\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can see that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A new invoice can be created with the event ",(0,i.jsx)(n.code,{children:"CreateInvoice"})," which takes the parameters found in ",(0,i.jsx)(n.code,{children:"CreateInvoiceParams"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The function ",(0,i.jsx)(n.code,{children:"newInvoice"})," describes what the properties of the invoice should be. The function will use\nthe class ",(0,i.jsx)(n.code,{children:"CreateInvoiceParams"})," to figure it out."]}),"\n",(0,i.jsxs)(n.li,{children:["When it is created, it has the state ",(0,i.jsx)(n.code,{children:"WaitingForApproval"})," and an email is sent."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"Approve"})," event can is only acceptable if the invoice has the state ",(0,i.jsx)(n.code,{children:"WaitingForApproval"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The invoice can be deleted if the invoice is either ",(0,i.jsx)(n.code,{children:"WaitingForApproval"})," or ",(0,i.jsx)(n.code,{children:"Approved"})," but not ",(0,i.jsx)(n.code,{children:"Payed"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.p,{children:"The events must be declared before they are used in the state machine. An event is declared as such:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["First create an object that extends one of ",(0,i.jsx)(n.code,{children:"VoidEventWithParameters"}),", ",(0,i.jsx)(n.code,{children:"InstanceEventNoParameters"})," or ",(0,i.jsx)(n.code,{children:"InstanceEventWithParameters"}),". E.g:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"object CreateInvoice : VoidEventWithParameters<Book, CreateInvoiceParams>(\n   forModel = Invoice::class, \n   isExternal = true,       // true makes it possible to trigger the event using a Command\n   parametersClass = CreateInvoiceParams::class)\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Add it in your state machine:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"externalEvents {\n    event(CreateInvoice, CreateInvoiceParams::class)\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"states",children:"States"}),"\n",(0,i.jsxs)(n.p,{children:["Your model can have many states but at minimum you must declare a ",(0,i.jsx)(n.code,{children:"voidState"}),' and one instance state. Each instance of your\nmodel will be in one of the instance states. The voidState is a bit special as it represents "the model doesn\'t\nexist yet". Models can only be created in the voidState.']}),"\n",(0,i.jsx)(n.p,{children:"The state names should be an enum."}),"\n",(0,i.jsx)(n.h2,{id:"blocks-and-executables",children:"Blocks and executables"}),"\n",(0,i.jsx)(n.p,{children:"Let's look more closely at the Approved state in the example above. There are two things, the first looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"onEvent(Pay) {\n  transitionTo(Payed)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:['We call this a "block". To be more specific, we can call it "a block for the \'Pay\' event". We see that there is only one\nthing in the block, namely ',(0,i.jsx)(n.code,{children:"transitionTo(Payed)"}),'. We call this an "executable". There may be more than one executable in a\nblock. All executables within a block will be executed in the same transaction, and it doesn\'t matter in which order they are written.']}),"\n",(0,i.jsx)(n.p,{children:"The following blocks are available:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"onEvent"}),": Will be triggered by an event via a ",(0,i.jsx)(n.a,{href:"/docs/usage/commands",children:"command"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"onEnter"}),": Will be triggered when the model enters this state. Not available in voidState."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"onExit"}),": Will be triggered when the model is about to leave this state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"atTime"}),": Will be triggered at a certain time unless the model has left the state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"after"}),": Will be triggered after a certain duration unless the model has left the state."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the block, you can use these executables:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"createModel"}),": Makes a model come into existence. Only possible in voidState."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"update"}),": Modifies the properties of a model."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"delete"}),": Deletes the model."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"transitionTo"}),": Makes the model transition to another state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"transitionWhen"}),": Conditional transition. E.g. \"if invoice value is larger than \u20ac10000 transition to 'waiting for CFO approval'\"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"createCommands"}),": Create secondary ",(0,i.jsx)(n.a,{href:"/docs/usage/commands",children:"commands"})," that will be executed in the same transaction. These are normally used\nto trigger other state machines."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"job"}),": Creates a ",(0,i.jsx)(n.a,{href:"/docs/advanced-topics/jobs",children:"job"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"action"}),": Triggers a background execution of a function. Use this if you don't need any of the stuff a\n",(0,i.jsx)(n.a,{href:"/docs/advanced-topics/jobs",children:"job"})," provides."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"transactions",children:"Transactions"}),"\n",(0,i.jsxs)(n.p,{children:["The blocks will happen in a transaction. This means that either all or none of the executables will be executed. As an\nexample: imagine you have a state machine for Invoices with a ",(0,i.jsx)(n.code,{children:"onEvent(Approve)"})," block which contains an ",(0,i.jsx)(n.strong,{children:"createCommands"})," executable.\nThis executable produces a secondary event ",(0,i.jsx)(n.code,{children:"SendMoney"})," but the rules for that event prevents ",(0,i.jsx)(n.code,{children:"SendMoney"})," from\nhappening. If the ",(0,i.jsx)(n.code,{children:"Approve"})," command is issued, it will fail and none of the executables will be executed."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);