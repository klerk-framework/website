"use strict";(self.webpackChunkklerk_website=self.webpackChunkklerk_website||[]).push([[422],{840:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var o=t(4848),s=t(8453);const a={sidebar_position:1},r="Concurrency",i={id:"advanced-topics/concurrency",title:"Concurrency",description:"As Klerk is designed to be simple, concurrency is something you can mostly ignore. However, there are",source:"@site/docs/advanced-topics/concurrency.md",sourceDirName:"advanced-topics",slug:"/advanced-topics/concurrency",permalink:"/docs/advanced-topics/concurrency",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Topics",permalink:"/docs/category/topics"},next:{title:"Jobs and Actions",permalink:"/docs/advanced-topics/jobs"}},c={},d=[];function h(e){const n={a:"a",h1:"h1",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"concurrency",children:"Concurrency"}),"\n",(0,o.jsx)(n.p,{children:"As Klerk is designed to be simple, concurrency is something you can mostly ignore. However, there are\nsome things that can be good to know about:"}),"\n",(0,o.jsxs)(n.p,{children:["Klerk defaults to ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/ACID",children:"ACID"}),"\nwith ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Serializable",children:"serializable"})," isolation. Locks are used\nto ensure that the system processes\nexactly one event at a time.\nAs events are processed sequentially, events will be enqueued if submitted when another event is being processed.\nReading is blocked during the processing of an event, ensuring strong consistency.\nThe reduced performance due to the locks is somewhat mitigated by\nthe fact that all data resides in memory. But since events are never processed\nin parallel, Klerk is not able to handle massive writes."]}),"\n",(0,o.jsxs)(n.p,{children:["When reading more than one thing, you probably want a guarantee that no event can occur between the reads. This is done\nby acquiring a read lock. Bear in mind that if you do a lot of work while you have a read lock, the write performance of\nthe\nsystem might degrade somewhat. This is usually not a problem when handling requests from other systems (e.g. responding\nto an HTTP request) but pay attention to this in your ",(0,o.jsx)(n.a,{href:"/docs/advanced-topics/jobs",children:"jobs"})," where you might initiate requests over the network. It is\noften\npossible to fix this by first read all data, release the lock and then to perform the work."]}),"\n",(0,o.jsx)(n.p,{children:"When reading, you will get a copy of the data which you can access after the read lock has been released. This means\nthat as soon as you release the read lock, an event may be processed and the data you have just read may be stale. If\nyou need to make sure you work with fresh data you can keep the read lock until you are done with the data (although\nthis may impact performance)."}),"\n",(0,o.jsx)(n.p,{children:"There may be situations when you want to submit more than one event for processing. If you submit them one by one, there\nis always a chance\nthat another event is processed in between. This can result in rejection of the subsequent events. To make sure\nall-or-none\nof your events will be accepted, you can submit a list of events or a function that produces events."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var o=t(6540);const s={},a=o.createContext(s);function r(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);