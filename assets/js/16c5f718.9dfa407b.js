"use strict";(self.webpackChunkklerk_website=self.webpackChunkklerk_website||[]).push([[1428],{2362:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=n(4848),o=n(8453);const a={sidebar_position:6},r="Authorization",s={id:"building-config/authorization",title:"Authorization",description:"No action (read model, trigger event, read event log) is allowed unless explicitly allowed. This makes it easy to create",source:"@site/docs/building-config/authorization.md",sourceDirName:"building-config",slug:"/building-config/authorization",permalink:"/website/docs/building-config/authorization",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"State machines",permalink:"/website/docs/building-config/state-machines"},next:{title:"Validation",permalink:"/website/docs/building-config/validation"}},l={},c=[];function u(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"authorization",children:"Authorization"}),"\n",(0,i.jsx)(t.p,{children:"No action (read model, trigger event, read event log) is allowed unless explicitly allowed. This makes it easy to create\na system that is secure-by-design. You declare both positive and negative\nauthorization rules. There must be at least one positive rule that allows the action and there must be no negative\nrule preventing the action. In this example, the 'Pay' event can only be triggered by the CFO when logged in with\nmulti-factor authentication:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"authorizationRules {\n    reads {\n        positive {\n            rule(::usersCanReadInvoiceItemNames)\n            rule(::usersInTheFinancialDepartmentCanReadEverything)\n        }\n        negative {\n        }\n    }\n    events {\n        positive {\n            rule(::theCFOCanTriggerAnyEvent)\n        }\n        negative {\n            rule(::mustBeAuthenticatedWithMultiFactor)\n        }\n    }\n    eventLog {\n        positive {\n            rule(::superadminCanReadEventLog)\n        }\n        negative {\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"As you can see above, you provide Klerk with functions that will be called when the user tries to do\nsomething. These functions consider the request and current state and returns a decision. So Klerk uses\nattribute-based access control (ABAC). If you prefer role-based access control (RBAC) you can easily implement that\nwith a role property on your User model."}),"\n",(0,i.jsx)(t.p,{children:'If your rule needs information that is not located within Klerk, it is recommended to provide that information in\nthe Context. In this case you would add a field called "isMultiFactorAuthenticated" to the context and use that in the\nrule. It is also possible to make requests to another system over the network within your rules but be aware that this\nmay severely impact performance.'})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const o={},a=i.createContext(o);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);