"use strict";(self.webpackChunkklerk_website=self.webpackChunkklerk_website||[]).push([[7795],{9674:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=n(4848),a=n(8453);const i={title:"Klerk"},o="Klerk",r={type:"mdx",permalink:"/website/",source:"@site/src/pages/index.md",title:"Klerk",description:"Klerk is Kotlin framework for managing data on the JVM. It replaces the database",frontMatter:{title:"Klerk"},unlisted:!1},l={},d=[{value:"Basic ideas",id:"basic-ideas",level:2},{value:"Declarative",id:"declarative",level:3},{value:"Simple",id:"simple",level:3},{value:"Event driven",id:"event-driven",level:3},{value:"Secure by design",id:"secure-by-design",level:3},{value:"Secure by default",id:"secure-by-default",level:3},{value:"When is Klerk a good fit?",id:"when-is-klerk-a-good-fit",level:2}];function h(e){const t={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"klerk",children:"Klerk"}),"\n",(0,s.jsx)(t.p,{children:"Klerk is Kotlin framework for managing data on the JVM. It replaces the database\nand\nbusiness-logic code layer in a traditional system. You are free to use other backend components to build\nwhatever you want on top of Klerk, such as"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"an API (JSON, REST, GraphQL) serving your frontend"}),"\n",(0,s.jsx)(t.li,{children:"a web app using server generated HTML"}),"\n",(0,s.jsx)(t.li,{children:"a microservice communicating via RPC or message queues"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Klerk is open sourced under AGPL (",(0,s.jsx)(t.a,{href:"commercial-licence",children:"commercial licenses"})," are available)."]}),"\n",(0,s.jsx)(t.p,{children:"Klerk means 'bookkeeper' in swedish."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Klerk is still in alpha. This means that the API is not yet stable."})}),"\n",(0,s.jsx)(t.h2,{id:"basic-ideas",children:"Basic ideas"}),"\n",(0,s.jsx)(t.p,{children:"The purpose of Klerk is to enable development of high quality information systems. To achieve this, Klerk is designed\nwith these ideas in mind:"}),"\n",(0,s.jsx)(t.h3,{id:"declarative",children:"Declarative"}),"\n",(0,s.jsx)(t.p,{children:"When using Klerk you first carefully declare your data and the rules that your data must obey:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Types"}),"\n",(0,s.jsx)(t.li,{children:"Validation"}),"\n",(0,s.jsx)(t.li,{children:"Which events are allowed when the data has a certain state"}),"\n",(0,s.jsx)(t.li,{children:"How do the events change the data"}),"\n",(0,s.jsx)(t.li,{children:"Who is allowed to trigger the events"}),"\n",(0,s.jsx)(t.li,{children:"Who is allowed to read certain data"}),"\n",(0,s.jsx)(t.li,{children:"... and more"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"You declare all this using code (Kotlin) and give the rules to Klerk.\nIt is now the responsibility of the framework to uphold the data integrity and make\nsure these rules are not broken."}),"\n",(0,s.jsx)(t.p,{children:'You can query the framework, not only for the data but also for the rules. The ability to query the rules can be\nvery useful when building a UI. Should the "Send invite" button be visible now? Let\'s ask the framework. Which fields\nshould the form contain? The framework knows. What are the validation rules of the email field? Ask the framework. Or\njust submit the fields as a dry-run event and the framework will tell you if there is any problem with the submitted\ndata.'}),"\n",(0,s.jsx)(t.p,{children:"This means that you only need to implement the business logic once, making it easy to keep the UI and rules in\nsync. It is even possible to build an auto-generated UI that is updated as soon as you change the business logic. In\nfact, Klerk comes with a built-in auto-generated admin UI and some other UI tools (e.g. an HTML form builder)."}),"\n",(0,s.jsx)(t.p,{children:"Being able to query the rules also creates new possibilities when it comes to system documentation. It is possible\ngenerate state diagrams which enables non-programmers to grasp how the system actually behaves. Having an up-to-date,\naccessible and understandable documentation is useful for many stakeholders (e.g. product owners, customers, testers,\nonboarding developers, support, sales)."}),"\n",(0,s.jsx)(t.p,{children:"Another benefit of this declarative approach is that Klerk can analyze the configuration and find\nproblems at startup. This reduces the risk of bugs showing up in production."}),"\n",(0,s.jsx)(t.h3,{id:"simple",children:"Simple"}),"\n",(0,s.jsx)(t.p,{children:"Klerk encourages you to write simple code. As you mostly write data structures and pure functions and use these\nto declare your rules, you rarely feel the need to write 'clever' code like layers of abstractions, multiple\ninheritance, classes with lots of dependencies and other stuff that complicates the system."}),"\n",(0,s.jsxs)(t.p,{children:["Systems build with Klerk are simple. Note that ",(0,s.jsx)(t.em,{children:"simple"})," means ",(0,s.jsx)(t.em,{children:"the opposite of complex"}),", not ",(0,s.jsx)(t.em,{children:"small"})," or ",(0,s.jsx)(t.em,{children:"limited"}),"; It is\nperfectly fine to build large systems with Klerk. One of the most important source of complexity is state.\nUnfortunately, information systems must handle state.\nKlerk aims to make state as simple as possible. So what we mean when say that systems build with Klerk are simple, we\nmean that the parts are not entangled. It is perfectly possible to look at one part and understand exactly what\nthat part means without knowing about the whole system. Likewise, it is possible to modify one part without affecting\nother parts of the system."]}),"\n",(0,s.jsxs)(t.p,{children:["As a developer, this simplicity means that you don't have to think about hard stuff like cache invalidation and race\nconditions (see ",(0,s.jsx)(t.a,{href:"/docs/advanced-topics/concurrency",children:"concurrency"}),")."]}),"\n",(0,s.jsx)(t.h3,{id:"event-driven",children:"Event driven"}),"\n",(0,s.jsx)(t.p,{children:"Data is changed by sending events to the framework. If you want to update the 'favoriteBook' property on a\n'User' model, you will not execute an SQL update command like with most databases. Instead, you will configure the\nsystem\nso that it accepts an event called 'Set favourite book' which takes some parameter. Then you declare on which type of\nmodel\nthe event should be available and some other stuff like validation and authorization. You also write a function which\nsays how the model should be changed by the event (in this case just replace the 'favoriteBook' with the event\nparameter)."}),"\n",(0,s.jsx)(t.p,{children:"As the data is changed via events, Klerk will automatically generate an audit log."}),"\n",(0,s.jsxs)(t.p,{children:["As mentioned, much of the complexity in a system is related to state. Klerk lets you use ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Finite-state_machine",children:"state machines"})," to manage states\nsafely. You will declare a state machine for each of your models. You design the model's states and tell the framework\nwhich events a certain state will accept, if there are any preconditions, and what should happen when the event is\ntriggered."]}),"\n",(0,s.jsx)(t.h3,{id:"secure-by-design",children:"Secure by design"}),"\n",(0,s.jsx)(t.p,{children:"All interaction with the data goes through Klerk. This means that Klerk can guarantee that all authorization rules are\nenforced. It is simply not possible for a developer to forget to check a security rule. While it is possible for a developer\nto bypass a rule, these exceptions requires the developer to explicitly state that the rule should not be enforced, making\nthis code stand out."}),"\n",(0,s.jsx)(t.h3,{id:"secure-by-default",children:"Secure by default"}),"\n",(0,s.jsxs)(t.p,{children:["All data interaction is denied unless explicitly allowed. To be more precise: in order for a data access to be allowed,\nthere must exist at least one ",(0,s.jsx)(t.a,{href:"/docs/building-config/authorization",children:"authorization rule"})," that allows the action, and\nthere must not exist any rule that denies the action."]}),"\n",(0,s.jsx)(t.h2,{id:"when-is-klerk-a-good-fit",children:"When is Klerk a good fit?"}),"\n",(0,s.jsx)(t.p,{children:"Klerk can help you manage the complexity in a system. But if you are building a trivial application, Klerk probably doesn't add enough value to motivate the learning."}),"\n",(0,s.jsx)(t.p,{children:'Klerk shines when mutations can be described as domain events (e.g. "the invoice has been approved") and\nwhen many of your business rules depends on state (e.g. "the invoice must be approved before it can be paid").'}),"\n",(0,s.jsx)(t.p,{children:"However, Klerk has some limitations:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Clerk is not horizontal scalable (yet). That said, the\nframework should be able to handle more than 1000 read requests per second."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"The framework is designed in such way that it never will be able to process thousands of events\nper second, but it should be able to sustain more than 100 events per second."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"As Clerk keeps all data in memory, it is not recommended to store images etc. in it. Note that it is possible to\nlet Clerk handle a subset of your data, so it is possible use Clerk for most data but handle images in a separate way."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Taken together, if you are expecting millions of concurrent users, Clerk is probably not a good fit unless you\ncan partition the data (e.g. single-tenant systems)."})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);